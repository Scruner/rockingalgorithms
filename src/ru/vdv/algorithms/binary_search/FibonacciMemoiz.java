package ru.vdv.algorithms.binary_search;

import java.util.Arrays;

public class FibonacciMemoiz {

    public static void main(String[] args) {
        /*При вызове метода в его параметр будем вводить не число, а переменную*/
        int n = 100;
        /*Чтобы запоминать участки кода, создадим массив*/
        long[] mem = new long[n + 1];
        /*Заполним массив числами (-1). Статический метод fill() позволит нам заполнить массив одинаковыми значениями.
         * Заполняем -1, для того чтобы обозначить, что метод fibNaive() с таким аргументом мы ещё не вызывали. Если же
         * mem[n] не будет равен -1, это будет означать, что мы уже вызывали fibNaive() с таким аргументом, поэтому
         * второй раз считать не надо, мы просто можем забрать этот сохранившийся элемент из нашего массива*/
        Arrays.fill(mem, -1);
        System.out.println(fibNaive(n, mem));
    }

    /*Чтобы избежать повторных вычислений, изменим метод с рекурсией с помощью мемоизации (будем запоминать промежуточные
     * результаты, а не вычислять их снова в каждом шаге*/
    private static long fibNaive(int n, long[] mem) {
        /*Будем запоминать с какими параметрами мы вызывали метод fibNaive(), если мы вызываем этот метода второй раз
         * с такими же аргументами, мы не пойдём дальше, будем выдавать результат вызова*/
        if (mem[n] != -1) {
            return mem[n];
        }
        if (n <= 1) {
            return n;
        }
        long result = fibNaive(n - 1, mem) + fibNaive(n - 2, mem);
        /*Помещаем наш результат в массив*/
        mem[n] = result;
        /*После того как поместили результат в массив, возвращаем его*/
        return result;
    }
}
